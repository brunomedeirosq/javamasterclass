useful intelij shortcuts:
CTRL + ALT + L reformat code
CTRL+ W select several block of code
CTRL + K open git commit tab
ALT + 1 open and close project window
CTRL+D duplicate selected content on new line
SHIFT+F9 debug run (main)
F8 when on debug to step over
SHIFT+F10 normal run (main)
ALT+F7 quick locate references for the highlighted word
ALT+INSERT generate code like getters and setters
CTRL+O open override methods options
CTRL + SHIFT + ENTER add "{" and "}" to code block

psvm create the public static void main method
sout create a system out println




jshell commands:
/list
/var

#wrapper classes for primitive data types with additional information like:
Integer.MIN_VALUE
Integer.MAX_VALUE

#to get width for different primitive data types that allow different whole number sizes:
Integer.SIZE
Short.SIZE
Long.SIZE

#important concept of overflow and underflow that the compiler will not evalute as error and will cause miss behavior caused from trying to store a size number in the wrong data type

#default data type for numbers in java is "int" even if we declare "long myNumber = 2147483648;", this will cause error since we need to put a sufix "L" to force java to deal with our number as long like this, "long myNumber = 2147483648L;"

jshell> Integer.MAX_VALUE
$17 ==> 2147483647

jshell> long myValue = 2147483647;
myValue ==> 2147483647

jshell> long myValue = 2147483648;
|  Error:
|  integer number too large
|  long myValue = 2147483648;
|

jshell> long myValue = 2147483648L;
myValue ==> 2147483648

double is the default data type for floating point numbers since it's more precise than float, it's larger and more precise than a float

bit is the smallest unit of data containing at most 2 logical states, normally 0 and 1

8 bits combine to make a single unit of addressable memory, called a “Byte”

however java byte with small "b" is a java primitive data type capable of storing 8 bits at a time

Byte.SIZE = 8 bits (in this case java Byte is a java wrapper class for primitive data type byte that have useful and additioal information such as max and min value, or size/width). Java Byte is a wrapper class used to store the primitive data type “byte” for easier access to built-in advanced functions.

https://codegym.cc/groups/posts/java-byte-keyword

double > 64 bits > 8 Bytes memory to store a number

float > 32 bits > 4 Bytes memory to store a number

1 Byte = 8 bits

Exame question:
To assign a double value (java default data type for floating numbers, decimal or real numbers) to a float variable we need to cast or use the sufix "F"/"f", since if we try to set a double (more precise data type) into a less precise data type like float the compiler will raise an error.

float myFloatNumber = 5.25; > ERROR
float myFloatNumber = 5.25F; > OK
float myFloatNumber = 5.25f; > OK
float myFloatNumber = (float) 5.25; > OK

char occupies 2 bytes of memory, or 16 bits, and thus has a witdh of 16 > the reason it's not just a single byte, is that a char is stored as a 2 byte number, similar to the short. This number gets mapped to a single character by Java.

unicode is an international encoding standard for use with different languages and scripts by which each letter, digit, or symbol is assigned a unique numeric value that applies across different platforms and programs.

Unicode examples:

U+0044
jshell> '\u0044'
$43 ==> 'D'

Dec 68
jshell> char test = 68;
test ==> 'D'

Important concept in JAVA: classes in Java are custom data types. Also a special code block that contain methods.

String concatenation > A String + anything else, gives us a String as a result, concatenating anything after the String as text to the initial String.

String class is immutable!
StringBuilder classe is mutable!

Importante example when using "variable++;" or "variable+=1;" as example 

jshell> {
   ...>     int result = 10;
   ...>     result -= 5.5;
   ...>     System.out.print(result);
   ...> }
4

the above expression is equal to

jshell> result = (int) (10 - 5.5)
result ==> 4

jshell> 10 - 5.5
$68 ==> 4.5

since the result is int data type when using result -= 5.5; java is doing (int) (10 - 5.5), casting to int, so the result is only the whole number 4, the integer part and the decimal part is discarded.

Intellij Notes:

using "psvm" and "tab" intellij will add the main class method declaration automatically

"public" java keyword is called an "access modifier" for java classes and allows us to define which parts of our code, or even someone else's code, can access a particular element.
"public" access modifier means other code can access this class.

"method" in java is collection of statements, one or more, that perform an operation

method called "main" is a special java method that java will looks when running a program. it's the entry point for any java code.

"if-then-else statement" most basic control flow statements called conditional logic

= assign

== equal operator that will evaluate on true or false

always use code block, {}

ampersand operator && (AND operator, both conditions should evaluate true)

two pipes operator || operator (OR operator, it enough that one of the conditions evaluate true)

! exclamation mark or NOT operator is Logical Complement Operator, it can be used for boolean variables to test the opposite value

boolean isCar = false;

careful when using if (isCar = true) since this mistake will set isCar to true and execute the block of code under if condition. we must use == operator to compare and not = to assign

ternary operator is a conditional operator that has three operands. the ternary operator is a shortcut to assigning one of two values to a variable, depending on a given condition
it's like a shortcut of the if-then-else statement

operand1 ? operand2 : operand3

operand 1 must be a condition that evaluates into a boolean result or must be a boolean variable
operand 2 can be any data type and will be returned when operand 1 is true
operand 3 can be any data type and will be returned when operand 1 is false

boolean isDomestic = (makeOfCar == "Volkswagen") ? false : true;

its equivalent to

boolean isDomestic = (makeOfCar!="Volkswagen"); //this assignment to a boolean variable of the condition result is more easy to read than the ternary operator example

Java code units as important concepts:

expression - an expression computes to a single value (does not include ; or data type from variables definition)

eg: int highscore = 50;
the expression is only: "highscore = 50"

eg: double kilometers = (100 * 1.609344);
the expression is only: "kilometers = (100 * 1.609344)"
the expression is also: "(100 * 1.609344)"

statement - statements are stand alone units of work

eg: double kilometers = (100 * 1.609344);
the complete line above is a java statement, including data type double and semicolon ;

code of blocks - code block is a set of zero, one or more statements, usually grouped together in some way to achieve a single goal

java methods concept: A method declares executable code that can be invoked, passing a fixed number of values as arguments

technically, a parameter is the definition as shown in the method declaration, and the argument will be the value that's passed to the method when we call it

some programing languages make a difference between a method that return a value as a function, and a method that doesn't return a value, or void as procedure.

declaring the method:
declaring modifiers like public or static, there are others
declaring the return type:
void is java keyword meaning no data is returned from a method
alternatively, the return type can be any primitive data type or class
if a return type is defined, the code block must use at least one return statement, returning a value, of the declared type or comparable type

A method is uniquely defined in a class by it's name, and the number and type of parameters that are declared for it. This is called the method signature.

You can have multiple methods with the same method name, as long as the method signature (meaning the parameters declared) are different.

java doesn't support default values for parameters. In Java the number of arguments you pass, and their type,
must match the parameters in the method declaration exactly

The "main" method is a special method for Java and we can't define methods inside methods, they should be defined inside the class curly brackets,
however we can call methods inside other methods, in this case we can use main method to call our own methods.


method overloading - method overloading occurs when a class has multiple methods, with same name, but the methods are declared with different parameters.
So we can execute a method with one name, but call it with different arguments.

A method signature consists of the name of the method, and the uniqueness of the declaration of its parameters.
In other words, a signature is unique, not just by the method name, but in combination with the number of parameters, their types, and the order in which they are
declared.

NOTE: A method's return type is not part of the signature.
NOTE: A parameter name is also not part of the signature.

IMPORTANT: The type, order, and number of parameters, in conjunction with the name, make a method signature unique.
A unique method signature is the key for the java compiler, to determine if a method is overloaded correctly.
The name of the parameter is not part of the signature, and therefore it doesn't matter, from the java's point of view, what we call our parameters.

key control flow statements in java:
switch statement (execute different code blocks based on different conditions)
three additional statements,
for statement (repeat code segments based on conditions)
while statement (repeat code segments based on conditions)
do while statement (repeat code segments based on conditions)

NOTE: switch allow something like the following example, several conditions (case 4: case 5: case 6:) value execute the same code:

switch (testValue) {
            case 1:
                System.out.println("Value is " + testValue);
                break;
            case 2:
                System.out.println("Value is " + testValue);
                break;
            case 3:
                System.out.println("Value is " + testValue);
                break;
            case 4: case 5: case 6:
                System.out.println("Value is " + testValue);
                break;
            default:
                throw new IllegalStateException("Unexpected value: " + testValue);
        }

switch (testValue) {
            case 1 -> System.out.println("Value is " + testValue);
            case 2 -> System.out.println("Value is " + testValue);
            case 3 -> System.out.println("Value is " + testValue);
            case 4, 5, 6 -> System.out.println("Value is " + testValue);
            default -> throw new IllegalStateException("Unexpected value: " + testValue);
        }

public static String getQuarter(String month) {
        switch (month) {
            case "January": case "February": case "March":
                return "First quarter";
            case "April": case "May": case "June":
                return "Second quarter";
            case "July": case "August": case "September":
                return "Third quarter";
            case "October": case "November": case "December":
                return "Fourth quarter";
        }
        return "Unexpected month: " + month;
    }

NOTE: in this example we don't need to use break in switch, since return will prevent the following block of code to be executed.
Also we don't need to use default in the switch since the return will exit the method with "default" code to be executed. However we could something like this
but will through an java exception and break the main method code execution.

public static String getQuarter(String month) {
        switch (month) {
            case "January": case "February": case "March":
                return "First quarter";
            case "April": case "May": case "June":
                return "Second quarter";
            case "July": case "August": case "September":
                return "Third quarter";
            case "October": case "November": case "December":
                return "Fourth quarter";
            default:
                throw new IllegalStateException("Unexpected month: " + month);
        }
    }

public static String getQuarterEnhanced(String month) {
        return switch (month) {
            case "January", "February", "March" -> "First quarter";
            case "April", "May", "June" -> "Second quarter";
            case "July", "August", "September" -> "Third quarter";
            case "October", "November", "December" -> "Fourth quarter";
            default -> {
                String badResponse = month + " is bad";
                yield badResponse;
            }
        };
    }

NOTE: When to use yield in a switch - Your switch statement is being used as a switch expression returning a value. Needs to be used in curly braces like { yield "test"}

Valid switch value types:

byte, short, int, char
Byte, Short, Integer, Character
String
enum

Important: Cannot use long, float, double or boolean or their wrappers.

Important concept switch behavior: once a switch case label matches the switch variable, no more cases are checked. Any code
after the case label where there was a match found, will be executed, until a break statement, or the end of the switch statement occurs.


Looping three statements:

for (for statement == for loop) - The for loop is more complex to set up but is commonly used when you are iterating over a set of values.
it repeatedly loops something until a condition is satisfied.
while - The while loop executes until a specified condition becomes false
do while - The do while loop always executes at least one and continues until a specified condition becomes false

Attention: do while loop needs a semicolon to end the while expression and the other loop statements don't.

 for (int i = 1; i <= 5; i++) {
             System.out.println(i);
         }

 int j = 1;
 while (j <= 5) {
     System.out.println(j);
     j++;
 }

 int k = 1;
 while (true) {
     if (k > 5) {
         break;
     }
     System.out.println(k);
     k++;
 }

 int z = 1;
 boolean isReady = false;
  do {
      if (z > 5) {
          break;
      }
      System.out.println(z);
      z++;
  } while (isReady);

int number = 0;
        while (number < 50) {
            number += 5;

            if (number % 25 == 0) {
            continue;
            }
            System.out.print(number + "_");
        }

Attention: check above the use of continue that will prevent the sout statement to be executed when number is evenly divided by 25 and assure that the loop keep executing until the expression is false.

Continue and break on loops:
- the "continue" and "break" statements both interrupt normal loop processing.
- the "continue" statement starts a new iteration, but continues to iterate through the loop.
- the "break" statement exits the loop, at the point it's executed, and no longer completes any code in the loop, and won't continue iterating any longer.

Scope: describes the accessibility of a variable. 'In scope' means the variable can be used by an executing block or any nested blocks.
'out of scope' means the variable is no longer available.
Local variables are always in scope, in the block they are declared.
They are also in scope for any nested blocks, os blocks contained within the outer block.

Scope best practices:
- to declare and initialize variables in the same place if possible
- and to declare variables in the narrowest scope possible

Attention: Local variables are a way to store and manipulate temporary data. In adition to local variables, we can set up data to be defined,
and used as part of a class, or an object.

Important concepts in JAVA:
- classes in Java are custom data types. Also a special code block that contain methods.
- an object is called an instance of a particular class (objects and instances are interchangeable terms).
- create a object == "instantiating a class"

difference between static field and instance field: check slide 69 regarding to table with differences!! (MUITO MUITO IMPORTANTE)

Parsing Techniques in Java:

System.in

System.console (example: System.console().readline("Hi, what's your name?");) -> in this case we used the method System.console().readline() to read input from command line

Command Line Arguments - This is calling the java program and specifying data in the call but doesn't let us create an interactive application in a loop in Java.

Scanner:
The scanner class is decribed as a simple text scanner, which can parse primitive types and strings.
To use the Scanner class, we have to create an instance of Scanner. This means we're creating an object of type Scanner (key word "new").

Class Instance Creation Expression:
Classname variablename = new Classname();

For reading input from the console or terminal, we instantiate a scanner object using new, followed by the Scanner classname, and passing System.in, in the
parentheses.

Scanner scanner = new Scanner(System.in);

String name = scanner.nextLine();

Note: scanner is an instance of class Scanner, scanner is a local object (local variable named scanner) that we can use to execute instance methods,
like nextLine() method, this is an instance method on scanner object.

For reading input from a file, same thing but passing as argument a File object in the parentheses.

File is another class provided by Java to reading and writing files.

Scanner scanner = new Scanner(new File("nameOfFileOnFileSystem"));

Note: "import java.util.Scanner" importing the class Scanner from library java.util

Exceptions in Java:
An exception is an error that happens in code. Some types of errors can be predicted and named.

An exception (or exceptional event) is a problem that arises during the execution of a program. When an Exception occurs the normal
flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore, these exceptions are to be handled.

An exception can occur for many different reasons. Following are some scenarios where an exception occurs.

- A user has entered an invalid data.

- A file that needs to be opened cannot be found.

- A network connection has been lost in the middle of communications or the JVM has run out of memory.

NOTE: Some of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.

Based on these, we have three categories of Exceptions. You need to understand them to know how exception handling works in Java.

Checked exceptions − A checked exception is an exception that is checked (notified) by the compiler at compilation-time,
these are also called as compile time exceptions. These exceptions cannot simply be ignored, the programmer should take care of (handle) these exceptions.

For example, if you use FileReader class in your program to read data from a file, if the file specified in its constructor doesn't exist,
then a FileNotFoundException occurs, and the compiler prompts the programmer to handle the exception.

Note − Since the methods read() and close() of FileReader class throws IOException,
you can observe that the compiler notifies to handle IOException, along with FileNotFoundException.

Unchecked exceptions − An unchecked exception is an exception that occurs at the time of execution. These are also called as Runtime Exceptions.
These include programming bugs, such as logic errors or improper use of an API. Runtime exceptions are ignored at the time of compilation.

For example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an ArrayIndexOutOfBoundsException exception occurs.

Errors − These are not exceptions at all, but problems that arise beyond the control of the user or the programmer.
Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise.
They are also ignored at the time of compilation.

Note - StackOverflowError is a runtime error which points to serious problems that cannot be caught by an application.
The java. lang. StackOverflowError indicates that the application stack is exhausted and is usually caused by deep or infinite recursion.

We can handle Exceptions with try catch block to handle specific exceptions (errors) from our code.

        try {
            //statements that might get errors
        } catch (Exception e) {
            //code to 'handle' the exception
        }

##############################################################################################

OOP Object Oriented Programming

In OOP encapsulation has two meanings:
1.º bundling of behavior (methods) and attributes (fields) on a single object.
2.º practice of hiding fields, and some methods, from public access.

##############################################################################################

State and behavior:

So modelling real world objects as software objects, is a fundamental part of Object Oriented Programming.

A software object stores its state in fields, which can also be called variables, or attributes.

And objects expose their behavior with methods.

A class is a template or a blueprint for creating objects. The class describes the data (fields), and the behavior (methods), that are relevant to the real world
object we want to describe. Fields and methods are class members. A class member can be a field, or a method, or some other type of dependent element.

Important:
- If a field is static, there is only one copy in memory, and this value is associated with the class, or template, itself.
- If a field is not static, it's called an instance field, and each object may have a different value stored for this field.
- A static method can't be dependent on any one object's state, so it can't reference any instance members. In other words,
any method that operates on instance fields, needs to be non-static.

##############################################################################################

Organizing classes - Classes can be organized into logical groupings, which are called packages. If we don't declare a package, the class implicitly belongs
to the default package.

A class is said to be a top-level class, if it is defined in the source code file, and not enclosed in the code block of another class type, or method.

A top-level class has only two valid "access modifier" options: public, none.

public - public means any other class in any package can access this class
       - when the modifier is omitted, this has a special meaning, called package access, meaning the class is accessible only to classes in the same package

An access modifier at the "member level", allows granular control over class members:
public - public means any other class in any package can access this class
protected - protected allows classes in the same package, and any subclasses in other packages, to have access to the member
          - when the modifier is omitted, this has a special meaning, called package access, meaning the member is accessible only to classes in the same
          package
private - private means that no other class can access this member

Important: As a general rule, all fields should be private (encapsulation), unlike the class, where usually we use public.

Example:

public class Car {

    //five fields for class Car
    //they are defined in the class's code block instead of being declared inside methods like local variables
    //when we create an object from this class then the values we assign to these fields represent the state of the object
    //unlike local variables, class variables should have some type of access modifier declared for it
    //if we don't declare a modifier to class variables Java declares the default one (package private), implicitly.
    private String make;
    private String model;
    private String color;
    private int doors;
    private boolean convertible;

}

##############################################################################################

null is a special keyword in java, meaning the variable or attribute has a type, but no reference to an object.

This means that no instance, or object, is assigned to the variable or field.

Fields with primitive data types are never null.

Default values for fields on classes - Fields on classes are assigned default values, intrinsically by Java, if not assigned explicitly.

fields with primitive data type as the following default values:
boolean as default value assigned false
byte, short, int, long, char as default value assigned 0
double and float as default value assigned 0.0

other types like String will have default value null (String is not a primitive type, but an object from java class String).

//getters and setters
getter - is a method on a class, that retrieves the value of a private field, and returns it.
setter - is a method on a class, that sets the value of a private field.
The purpose of these methods is to control, and protect, access to private fields.

Note: the getter and setter method signatures are part of car's public interface, but the attribute names and types aren't. This means that
we could change name of the fields, our internals in our class, but the methods that allow access and modify our fields remains the same so
every use of our class remains untouched and working as expected.

"this" is a special keyword in Java
What it really refers to is the instance that was created when the object was instantiated.
So this is a special reference name for the object or instance, which it can use to describe itself.
And we can use this to access fields on the class.

Important:

An uninitialized variable, as we saw in the first instance, causes a compile time error.
example:
Car car;
car.setMake("Porsche");

An initialized variable with null reference will not cause compile time error but will throw an exception at runtime.
example:
Car car = null; (doesn't have a reference to valid instance of a car)
car.setMake("Porsche");

##############################################################################################

A constructor is used in the creation of an object, that's an instance of a class.

It is a special type of code block that has a specific name and parameters, much like a method.

It has the same name as the class itself, and it doesn't return any values.

You never include a return type from a constructor, not even void.

We should specify an appropriate access modifier, to control who should be able to create new instances of the class.

public class Account { //this is the class declaration

 public Account() { //this is the constructor declaration
    //constructor code is code to be executed as the object is created
 }
}

If a class contains no constructor declarations, then a default constructor is implicitly declared.

This constructor has no parameters, and is often called the no-args (no arguments) constructor.

If a class contains any other constructor declarations, then a default constructor is NOT implicitly declared.

The purpose of the constructor is, to essentially initialize the object that we are creating, and do whatever else we need to happen,
while the object is being instantiated.

Constructors overloading is declaring multiple constructors, with different formal parameters.

The number of parameters can be different between constructors.

Or if the number of parameters is the same between two constructors, their type or order of the types must differ.

Important concept: Constructor Chaining - which is the process of calling one overloaded constructor from another. So constructor chaining,
                    is when one constructor explicitly calls another overloaded constructor.

    NOTE: - constructor can only be called from another constructor
          - special statement this() is mandatory to execute another constructor, passing it arguments if required
          - this() must be first executable statement, if it's used from another constructor

    Rule of thumb: in constructors don't call setters or any other method, other than another constructor within those constructors.

example of overloading constructor:

public Account(int accountNumber, double accountBalance, String customerName, String email, String phoneNumber) {
        System.out.println("Account constructor with parameters called");
        this.accountNumber = accountNumber;
        this.accountBalance = accountBalance;
        this.customerName = customerName;
        this.email = email;
        this.phoneNumber = phoneNumber;
    }

    //constructor chaining
    public Account() {
        //special use of this with () and parameters that match in order the type from the constructor with same name but with the specified parameters
        this(5876, 2.5, "Bruno", "brunoq@gmail.com", "916905477");
        System.out.println("Empty constructor called");
    }

##############################################################################################

reference, object, instance, class meaning in the context of Java programming:

building house analogy with class (plans == template == blueprint == class) and objects (instance of the class)

- class is a blueprint (template) for the house - this means we can build as many houses as we like, based on those plans (blueprints/templates)

- object is one of the houses we build based on the plans - this means each house built(object) is an instance of the class

- reference, each house (object) we build has an address (a physical location) - This means we have a reference where the house (object) is located

Note: references to objects can be copied without touching the object itself, we only are manipulating the physical location to the house and not the house itself.
      we can pass references as parameters to constructors and methods.

Important: In Java we always have a reference to an object in memory through a variable, like in the following example. We can't access directly an object, in
            Java the only thing we have is reference stored in a variable to the place in memory where the object is stored.

House blueHouse = new House("blue"); //this line we are instantiating a new object from class House and saving the reference to this object in variable "blueHouse"
House anotherHouse = blueHouse; //this line we are copying and saving the reference in memory to the same object previously instantiated

//so in blueHouse and anotherHouse we have with these statements the reference for the same object in memory

Note:

new House("red"); // in this statement a new object was created from class House but we didn't create a reference to the new object. So the object exists in
                    memory, it's possible to compile without errors, but we can't communicate with it, after the statement is executed.

this object will stay in memory with no references to it, until java's automatic process, called garbage collection, figures out there is no running code with a
reference to that object and deletes it.

##############################################################################################

Static versus Instance Variables - Static variables are also known as static member variables. Every instance of the class shares the same static variable.
      So if changes are made to that variable, all other instances of that class will see effect of that change. So we should always use the class name to access
      a static variable value instead of object. An instance isn't required to exist, to access the value of a static variable (Dog.genus - in static variables
      don't have to instantiate a class or creating an object to get it's value, we can use class name.static variable name).

      example:

      class Dog {
        static String genus = "Canis";

        void printData() {
            Dog d = new Dog();
            System.out.println(d.genus); // confusing!!!
            System.out.println(Dog.genus); // clearer that we are accessing the variable value through class Dog which is only possible for static variables.
        }
      }

Instances Variables:
- they don't use the static keyword
- they are also known as fields, or member variables
- instance variables belong to a specific instance of a class
- each instance has it's own copy of an instance variable
- every instance can have a different value
- Instance variables represent the state, of a specific instance of a class

##############################################################################################

Static vs instance methods

Static methods:
- static methods are declared using a static modifier
- static methods can't access instance methods and instance variables directly
- they are usually used for operations that don't require any data from an instance of the class (from 'this')
- 'this' keyword is the current instance of a class, so inside a static method, we can't use the 'this' keyword
- rule of thumb, a method that doesn't use instance variables, that method should probably be declared as a static method
- static methods are called as ClassName.methodName(); or methodName(); only if in the same class
- static methods doesn't require an instance to be created

Instance methods:
- instance methods belong to an instance, of a class;
- to use an instance method, we need to instantiate the class first, usually by using the new keyword
- instances methods, can access instance methods and instance variables directly
- instance methods can also access static methods and static variables directly (we don't have to use the keyword 'this' and we don't have to use the Class)
- should a method be static? -> does it use any fields (instance variables) or instance methods? -> if "yes" -> it should probably be an instance method
-> if "no" it should probably be a static method

##############################################################################################

POJO/bean/JavaBean - Plain Old Java Object (remember that a class can be thought as a super data type):
- is a class that generally only have instance fields
- it's used to house data, pass data, between functional classes
- few if any methods other than getters and setters
- many database frameworks use POJO's to read data from, or to write data to, database, files or streams.
- A POJO is sometimes called an Entity, because it mirrors database entities
- another acronym is DTO, for Data Transfer Object.

Note: A JavaBean is a POJO with extra rules applied to it. This rules allow that Java framework have a standard way to manipulate, and manage these objects.

##############################################################################################

Annotations: (example: @overriden)

- Annotations are a type of metadata;
- Metadata is a way of formally describing additional information about our code;
- Annotations are more structured and have more meaning, than comments;
- This is because they can be used by the compiler, or other types of pre-processing functions, to get information about the code;
- Metadata doesn't effect how the code runs, so the code will still run, with or without the annotation;

##############################################################################################

Overridden Method

- An overridden method is not the same thing as an overloaded method;
- An overridden method is a special method in Java, that other classes can implement, if they use a specified method signature;
- System.out.println(s); is equal to use System.out.println(s.toString()); - this is possible due to built-in feature in Java
that every object, when passed to System.out.println will have the toString method implicitly executed if we have the @override toString() method implemented
in our class;

##############################################################################################

Note: Code generated by the IDE (like intellij) for constructors, getter, setters is called "boilerplate code".

##############################################################################################

Record Type (since JDK 14 and officially part of JDK16):

- purpose of replacing the boilerplate code of the POJO, but to be more restrictive.
- Java calls them "plain data carriers".
- record is a special class than contains data, that's not meant to be altered.
- it seeks to achieve immutability, for the data in its members.
- it contains only the most fundamental methods, such as constructors and accessors.
- developer don't have ro write or generate any of this code.

example: public record LPAStudent(String id, String name, String dateOfBirth, String classList) {

         }

"String id, String name, String dateOfBirth, String classList" is called record header. The record header consists of a record components,
a comma delimited list of components.
For each component in the header, Java generates:
- A field with the same name and declared type as the record component.
- The field is declared private and final.
- The field is sometimes referred to as a component field.
- Java generates a toString() method that prints out each attribute in a formatted String.
- Java generate a public accessor method for each component, with same name and type of the component. example access method for "id" is id()
- record type objects are immutable and don't generate or allow setters methods, only getters to access data
- so we have immutable records since there are more immutable data transfer objects, and keeping them well encapsulated, this way we protect better data from
unintended mutations.

Conclusion: if we need to modify object data we should use "POJO" instead of "record type", since "record type" has more restrictions to prevent modifying data.

##############################################################################################

VERY IMPORTANT JAVA CONCEPT : INHERITANCE / inheritance

- as a form of code re-use
- allow to organize classes into a parent-child hierarchy, which lets the child inherit (re-use), fields and methods from its parents
- a child class can only have one direct parent in Java, but inherit from its parent class's parent, and so on

example: Class Model for Animal and Dog
- Dog inherits from Animal
- Dog 'IS A' type of Animal
- Dog object will inherit Animal's attributes (type, size and weight)
- Dog object also will inherit Animal's methods (move and makeNoise)
- we can specialize Dog class with its own fields and behaviors

public class Dog extends Animal {

    public Dog() {
            super();
        }

}

extends
- Using extends specifies the superclass (or the parent class) of the class we're declaring
- Dog is a subclass, or a child class, of Animal
- Animal is a parent, or super class, of Dog
- class can specify one, and only one, class in its extends clause

super() rules of use
-  super() is a lot like this()
- call's a constructor from the super class, directly from the sub class's constructor
- like this(), it has to be the first statement of the constructor
- this() and super() can never be called form the same constructor
- if we don't make a call to super(), then java makes it, using super's default constructor
- if our super class doesn't have a default constructor, than we must explicitly call super()
in all of your constructors, passing the right arguments to that constructor
- all subclasses can execute methods, even though the code is declared on the parent class
- code doesn't have to be duplicated in each subclass
- we can use code, from the parent
- we can change that code for the subclass

Overriding a method
Overriding a method means we create a method on a subclass, which has the same signature (method name and the number and type of parameters)
as a method on a super class.
we override a parent class method, when we want the child class to show different behavior for that method.

Important for overridden method:
1.º it allow to implement completely different behavior, overriding the behavior of the parent
2.º it can simply call the parent class's method, which is somewhat redundant to do
3.º the method can call the parent class's method, and include other code to run, so it can extend the functionality for the Dog, for that behavior

example:

 @Override
    public void move(String speed) {
        super.move(speed);
        System.out.println("Dogs walk, run and wag their tail");
    }

##############################################################################################

Polymorphism

- means many forms: in the class Animal example, Animal can take multiple forms like Animal, Dog or Fish.

Advantages:
- it makes code simpler
- it encourages code extensibility

##############################################################################################

java.lang.object - special Java class and is intrinsically extended by all classes. We don't have to explicitly extend. Belongs to java.lang
                   Class object is the root of the class hierarchy. Every class has Object as a superclass.
                   All objects, including arrays, implement the methods of this class.

Important: Java only supports one class in the extends class. The inheritance tree is cumulative, meaning that PrimarySchoolStudent inherits
            both Student members, and Object members. Object members are accessible, as long as Student doesn't override them.
            Because Student override toString(), we no longer can simply call the toString implementation on Object.

##############################################################################################

this vs super "keywords" in Java (review video lesson 94 very important)

super - allow to access or call parent class members (variables and methods)

Note: super is commonly used with method overriding, when we call a method with same name, from the parent class.

class SubClass extends SuperClass { //subclass aka child class
 //overrides methods from the parent class
 @Override
 public void printMethod(){
    super.printMethod(); //calls the method in the SuperClass (parent)
    System.out.println("Printed in Subclass.");
 }
}

this - allow to call current class members (variables and methods)

Important: We can use either of them anywhere in a class, except for static elements, like a static method.
Any attempt to do so there, will lead to compile time errors.

Note: this is required, when there is a parameter with same name, as an instance variable or field.

public void setColor(String color) {
//this keyword is required, same parameter name as field
this.color = color;
}

public String getColor() {
//this is optional
return color; //same as return this.color;
}

this() vs super() call "keywords" in Java (a constructor can have a call to super() or this(), but never both)

These are known as calls, since it looks like a regular method call, although we're calling certain constructors.

this() - allow to call a constructor, from another overloaded constructor in the same class. this() can only be used in a constructor, and it
         must be the first statement in a constructor. it's used with constructor chaining, when one constructor calls another constructor, and
         it helps to reduce duplicated code.

super() - only way to call a parent constructor, is by calling super(), which calls the parent constructor. The call to super() must be the first
          statement in each constructor.

Important: java compiler puts a default call to super(), if we don't add it, and it's always a call to the no argument constructor,
            which is inserted by the compiler.

##############################################################################################

method overloading vs method overriding (review important concepts in video lesson 95)

Methods will be considered overloaded if both methods follow the following rules:
- methods must have the same method name;
- methods must have different parameters;
If methods follow the rules above:
- they may or may not have different return types;
- they may or may not have different access modifiers;
- they may or may not throw different checked or unchecked exceptions.

Note: method overloading, can also be called as compile-time polymorphism. This means the compiler is determining the right method to call,
      based on the method name and argument list.

Method overriding, means defining a method in a child class, that already exists in the parent class, with the same signature (the same name, same arguments).
extending parent class, the child class gets all the methods defined in the parent class (those methods are also known as derived methods).

Note: Method overriding is also known as Runtime Polymorphism, or Dynamic Method Dispatch,
      because the method that is going to be called, is decided at runtime, by the Java virtual machine.

Important: We can't override static methods, only instance methods can be overridden.

A method will be considered overridden, if we follow these rules.
- it must have the same name and same arguments;
- return type can be a subclass of the return type in the parent class;
- it can't have a lower access modifier. In other words, it can't have more restrictive access privileges;
- For example, if the parent's method is protected, then using private in the child's overridden method is not allowed. However, using public for the
    child's method would be allowed, in this example.

Important points about overriding:
- only inherited methods can be overridden, methods can be overridden only in child classes;
- constructors and private methods cannot be overridden;
- methods that are final cannot be overridden;
- a subclass can user super.methodName() to call the superclass version of an overridden method.

##############################################################################################

Text Block (JDK 15) - special format for multi-line String literals. It's simply a String, with new representation in the source code.

Example:
public class Main {

    public static void main(String[] args) {

        String bulletIt = "Print a Bulleted List:\n" +
                "\t\u2022 First Point\n" +
                "\t\t\u2022 Sub Point";

        System.out.println(bulletIt);

        // text between triples quotes is a text block and printed as was written with tabs and new lines without using the \t or \n like in previous example
        String textBlock = """
                Print a Bulleted List:
                        \u2022 First Point
                            \u2022 Sub Point
                """;

        System.out.println(textBlock);

    }

}

##############################################################################################

Format specifiers using printf

%d format specifier that start with % symbol and ends with conversion symbol, in this case, "d" for decimal integer value. But we can have between % and d, several
    options.

// printf doesn't end with a new line, but this method as multiple arguments, the first is a String which will be printed to
// %d is a placeholder for other data
int age = 35;
System.out.printf("Your age is %d\n", age);

int yearOfBirth = 2023 - age;

System.out.printf("Age = %d, Birth year = %d", age, yearOfBirth);

Format specifiers using format from class String, static methods:

 //two format methods on String class, static methods. we are using them through the class "String.format"

        String formattedString = String.format("Your age is %d",age);
        System.out.println(formattedString);

        formattedString = "Your age is %d".formatted(age);
        System.out.println(formattedString);

##############################################################################################

String vs StringBuilder

String Class - Because String is immutable, each method call returns a new instance of a String.

Instantiating String Objects:

String hello = "Hello";
String helloWorld = "Hello" + "World";
String badHello = new String("Hello"); // Valid code, but redundant

StringBuilder Class - Java provides a mutable class that lets us change its text value.

Instantiating StringBuilder Objects:

StringBuilder helloBuilder = new StringBuilder("Hello");
StringBuilder emptyBuilder = new StringBuilder();
StringBuilder emptyBuilder5 = new StringBuilder(5);
StringBuilder stringBuilder = new StringBuilder(helloBuilder);

There are four ways to create a new StringBuilder object, using the new keyword:
- Pass a String;
- Pass no arguments at all;
- Pass an integer value;
- Pass some other type of character sequence (like StringBuilder).

String methods vs StringBuilder methods:

- String methods create a new object in memory, and return a reference to this new object.

- StringBuilder methods return a StringBuilder reference, but it's really a self-reference or a reference to the same object.
  Unlike Strings we can call methods on StringBuilder, without the need to assign the results to intermediate variables, as we saw with Strings.
  StringBuilder methods return this self-reference, to support chaining methods together.


Example to show difference between String (immutable) and StringBuilder (mutable):

public class Main {
    public static void main(String[] args) {

        String helloWorld = "Hello" + " World";
        helloWorld.concat(" and Goodbye");

        StringBuilder helloWorldBuilder = new StringBuilder("Hello" + " World");
        helloWorldBuilder.append(" and Goodbye");

        printInformation(helloWorld);
        printInformation(helloWorldBuilder);

    }

    public static void printInformation(String string) {
        System.out.println("String = " + string);
        System.out.println("Length = " + string.length());
    }

    public static void printInformation(StringBuilder builder) {
        System.out.println("String = " + builder);
        System.out.println("Length = " + builder.length());
    }

}

Output:
String = Hello World
Length = 11
String = Hello World and Goodbye
Length = 23

############################################################################################## SLIDE 101

Composition, Polymorphism, Encapsulation

Inheritance defines an IS A relationship

Composition defines an HAS A relationship

Important: Why is Composition preferred over Inheritance in many designs?

The reasons composition is preferred over inheritance:
- Composition is more flexible. You can add parts in, or remove them, and these changes are less likely to have a downstream effect.
- Composition provides functional reuse outside of the class hierarchy, meaning classes can share attributes & behavior, by having similar components,
    instead of inheriting functionality from a parent or base class.
- Java's inheritance breaks encapsulation, because subclasses may need direct access to a parent's state or behavior.
- Inheritance is less flexible since adding a class to, or removing a class from, a class hierarchy, may impact all subclasses from that point.
- In addition, a new subclass may not need all the functionality or attributes of its parent class.

############################################################################################## SLIDE 104

Encapsulation (why hide things in Java)

- to make the interface simpler, hide unnecessary details;
- protect integrity of data on an object, hide or restrict access to some of the data and operations;
- To decouple the published interface from the internal details of the class, we may hide actual names and types of class members.

Problems when not using encapsulation properly:

- allow direct access to data on an object, bypassing checks, and additional processing that our class through specific methods has in place to manage data;
- allowing direct access to fields, means calling code would need to change, when we edit any of the fields;
- Omitting a constructor, that would accept initialization data, may mean the calling code is responsible for setting up this data, on the new object.

Always use encapsulation:

- protect the members of the class, and some methods, from external access;
- prevents calling code from bypassing the rules and constraints, we've built into the class;
- when creating a new instance, it's initialized with valid data;
- we are making sure that there's no direct access to the fields.

Encapsulation principles:

- create constructors for object initialization, which enforces that only objects with valid data will get created;
- use the private access modifier for your fields;
- use setter and getter methods sparingly, and only as needed;
- use access modifiers that aren't private, only for the methods that the calling code needs to use.

############################################################################################## SLIDE 107/108

Polymorphism (very important concept and example of encapsulation and polymorphism on java project "Polymorphism" slide 108)

- ability to execute different behavior, for different types, which are determined at runtime.
- in the polymorphism example the two next lines in the main method allowed this different behavior with the great advantage
  of enabling the writing generic code, based on the base class, or a parent class. And this code in the main class is extendable,
  meaning is doesn't have to change, as new subclasses become available.

 Movie movie = Movie.getMovie(type,title);
 movie.watchMovie();

 This code can handle any instance that are a Movie, or a subclass of movie, that are returned from the factory method (example below).

  public static Movie getMovie(String type, String title) {
         return switch (type.toUpperCase().charAt(0)) {
             case 'C' -> new Comedy(title);
             case 'A' -> new Adventure(title);
             case 'S' -> new ScienceFiction(title);
             default -> new Movie(title);
         };
     }

############################################################################################## SLIDE 109

var - special contextual keyword in Java, that lets our code take advantage of "Local Variable Type Inference" (LVTI introduced on Java 10)!

It's called Local Variable Type Inference for a reason, because:
- it can't be used in field declarations on a class.
- it can't be used in method signatures, either as a parameter type or a return type.
- it can't be used without an assignment, because the type can't be inferred in that case.
- it can't be assigned a null literal, again because a type can't be inferred in that case.

examples:

var airplane = Movie.getMovie("C","Airplane");
airplane.watchMovie();

var plane = new Comedy("Airplane");
plane.watchComedy();

Run Time vs Compile Time Typing

compile time type => declared type, this type is declared either as a variable reference, or a method return type, or a method parameter, for example.

Note: in many cases, the compile time type, is the declared type to the left of the assignment operator.

run time => we don't declare a type for the compiled reference type, it gets inferred, but the byte code is the same, as if we had declared it.

Note: what is returned on the right side of the assignment operator, from whatever expression or method is executed, sometimes can only be determined at runtime,
      when the code is executing conditionally, through the statements in the code.

Important:

it's possible to assign a runtime instance, to a different compile time type, only if certain rules are followed.
One example of this use case:
    inheritance rule => we can assign an instance to a variable of the same type, or a parent type, or a parent's parent type, including java.lang.Object, the ultimate base class.

Conclusion:

Why are runtime types different than compile time types?

Because of polymorphism. Polymorphism let us write code once, in a more generic fashion. These two lines of code, using a simple compile type of Movie, actually supported four different runtime types.

 Movie movie = Movie.getMovie(type,title);
 movie.watchMovie();

Each type was able to execute behavior unique to the class.

############################################################################################## SLIDE 110 - OOP Part2 - Polymorphism - Testing the runtime type using the instanceof operator

And how do we test what the runtime type, of a variable really is at runtime, if the declared type is something else?

Examples on approach to deal with casting over generic objects in runtime:

Object unknownObject = Movie.getMovie("C", "Airplane");

if (unknownObject.getClass().getSimpleName() == "Comedy") {
    Comedy c = (Comedy) unknownObject;
    c.watchComedy();
} else if (unknownObject instanceof Adventure) {
    ((Adventure) unknownObject).watchAdventure();
}

Note:
    - The instanceof operator, lets you test the type of an object or instance.
    - The reference variable we are testing, is the left operand.
    - The type we are testing for, is the right operand.
    - Adventure is not in quotes, meaning we're not testing the type name, but the actual type.
    - This operator returns true, if unknownObject is an instance of Adventure.

############################################################################################## SLIDE 116 - Organizing Java Classes, Packages and Import Statements

A package is a namespace that organizes a set of related types. In general, a package corresponds to a folder or directory, on the operating system, but this isn't a requirement.
When using an IDE, like Intellij, we don't have to worry about how packages and classes are stored on the file system.
The package structure is hierarchical, meaning we group types in a tree fashion. Common practise, packages names should be all lower case.

Example:

In the following code, we're telling Java to import all classes from the java.util package, with the use of the asterisks, after the java.util package reference.

import java.util.*;

Another important example, we might have a package for utility classes, that can provide common functionality, for all of our classes to access.

Packages let us organize our classes by functionality, or relationships.

Packages also let us encapsulate our classes, from classes in other packages.

There can be only one package statement, because a class or type can only be in a single package.

A class's fully qualified class name (FQCN) consists of the package name and the class name.

package dev.lpa.package_one;

import java.util.*;

public class Main {

    public static void main(Strings[] args) {
        Scanner scanner = new Scanner(System.in);
    }

}

So this class's fully qualified name is, dev.lpa.package_one.Main.

As another example, the FQCN of the Scanner Class in this code, is java.util.Scanner

If we don't define packages for our classes, the default package is used, however there is a main disadvantage, we can't import types from the default package into other classes,
outside of the default package. In other words, we can't qualify the name, if it's in the default package, and we can't import the classes from the default package.

############################################################################################## SLIDES 117 - ARRAYS

Array - is a data structure that allows us to store multiple values, of the same type, in a single variable.

The default values of a numeric array elements are set to zero.

If we try to access an index that is out of range, Java will give us an ArrayIndexOutOfBoundsException, which indicates that the index is out of range.

The size of an array, once created, is fixed.

 //variable myIntArray stores a reference, means an address to the object in memory, but not the object itself.
 //the myIntArray stores an address or reference to an array in memory
 //the new keyword is creating a new object in memory, in this case an array data structure of length 5 and the myIntArray variable is storing the reference/address to that object
 int[] myIntArray = new int[5];
 //here we are storing the same reference for the same object created before on a new variable from same type int[] but not creating a new one
 int[] anotherArray = myIntArray;
 //both variables are referencing the same array in memory, so there's only one copy of the array
 //references types represent the address of the variable, rather than the data itself

 Important concept: The simplest way to think of a variable is, it's a way to store a primitive value (a value type), or it's a way to store a reference to an object.
                    when we pass a variable to an argument, we're never really passing an object, but only the reference(or address) to that object. And Java makes a copy
                    of that reference, not a copy of the object itself, when it copies the method parameter.

array creation:

int[] integerArray = new int[10]; //integerArray will have 10 elements

we can't change the size of an array, after the array is instantiated.

we can't add or delete elements, we can only assign values to one of the ten elements in this array, in this example.

int[] firstTen = {1,2,3,4,5,6,7,8,9,10}; //this is ok - anonymous array initializer - it' called anonymous because the type isn't included, but java
can figure it out because it's being used in a declaration statement.

int[] newArray;
newArray = new int[]{5,4,3,2,1}; //this is ok

int[] newArray;
however this can't be done:
newArray = {5,4,3,2,1}; // we can't use anonymous version of the array initializer in a statement outside of a declaration statement.

Array initialization and default element values:
- primitive types for any kind of numeric primitive is zero (int, double or short)
- booleans the default value is false
- for any class type the elements will be initialized to null

example of "for each" or for enhanced loop that allow us to iterate from begin to end from elements without using array indexes position
so if we are just looking for a way to process elements from start to finish, and not trying to set, swap or sort elements.

 int[] newArray;
 newArray = new int[5];

 for (int i = 0; i < newArray.length; i++) {
             newArray[i] = newArray.length - i;
         }

 for (int element : newArray) {
            System.out.print(element + " ");
        }

java.util.Arrays

Arrays Class inherits from java.util.Object's functionality.

Java provides a helper class named java.util.Arrays, providing common functionality,
these are static methods on Arrays, so are class methods, not instance methods.

example: System.out.println(Arrays.toString(newArray));

Important: An array can be treated like any other object instance in Java.

Example:

Object objectVariable = newArray;

if (objectVariable instanceof int[]) {
    System.out.println("objectVariable is really an int array");
}

Object[] objectArray = new Object[3];
objectArray[0] = "Hello";
objectArray[1] = new StringBuilder("world");
objectArray[2] = newArray;

Arrays are usually used to manage many items of the same type.

Some common behavior for arrays would be sorting, initializing values, copying the array and finding an element. -> this behavior isn't on the array itself,
but it's provided on a helper class, java.util.Arrays

############################################################################################## SLIDES 121 - SEARCHING IN ARRAYS

Using intervals to search - more efficient than linear or sequential search however there are a few considerations to use interval search such as binary search.

In binary search intervals are continually split into two, hence the word binary.

the static method, binarySearch is on the Array class:

- the array must be sorted
- if there are duplicate values in the array, there's no guarantee which one it'll match on
- elements must be comparable. Trying to compare instances of different types, may lead to errors and invalid results

This method returns:

- the position of a match if found
- returns -1 when no match was found
- a positive number may not be the position of the first match

############################################################################################## SLIDES 125 - Variable Arguments(Varargs)

Arrays as method parameters

public static void main(String... args) {

}

instead of the usual

public static void main(String[] args) {

}

(String... args) is a special designation for Java, that means, Java will take zero, one, or many Strings, as arguments to this method, and create an array with
which to process them, in the method.

When can we use variable arguments (varargs)?
- There can be only one variable argument in a method
- The variable argument must be the last argument

public class Main {

    public static void main(String... args) {
        System.out.println("Hello World!");

        String[] splitString = "Hello World Again".split(" ");
        printText(splitString);

        System.out.println("_".repeat(20));
        printText("Hello");

        System.out.println("_".repeat(20));
        printText("Hello", "World", "again");

        System.out.println("_".repeat(20));
        printText();



    }

    private static void printText(String... textList) {
        for (String text:
             textList) {
            System.out.println(text);
        }
    }

}


mutating method - meaning it has impact on the calling code's data. when data passed as parameter in the called method is modified by the method.

############################################################################################## SLIDES 128 - Two-Dimensional Arrays

initialize two-dimensional, and define the size of the nested arrays, as shown here.

int[][] myArray = new int[3][3];

This statement says we have an array of 3 nested arrays, and each nested array will have three ints.

int[][] mySecondArray = new int[3][];

initialization is an array of 3 null elements. We are limited to assigning integer arrays to these elements, but they can be any length.

